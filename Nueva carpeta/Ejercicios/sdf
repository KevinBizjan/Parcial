 // ====== ESTRUCTURA UNIVERSAL EQUALS/HASHCODE ======
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;

        Material otro = (Material) obj;

        return this.codigo.equalsIgnoreCase(otro.codigo);
    }

    @Override
    public int hashCode() {
        return codigo.toUpperCase().hashCode();
    }
}

ðŸŸ¦ 1. AGREGAR (siempre igual)
âœ” Ejemplo Material (Libro y Revista)
public void agregarLibro(Libro l) {
    libros.add(l);
}

public void agregarRevista(Revista r) {
    revistas.add(r);
}


ðŸ§  Estructura universal:

public void agregar(Tipo obj) {
    lista.add(obj);
}


ðŸ‘‰ Da igual si es libros.add(l) o autos.add(a) o computadoras.add(c).

ðŸŸ© 2. BUSCAR (siempre igual)
âœ” Ejemplo Material (Libro y Revista)
public Material buscar(String codigo) {
    if (codigo == null) return null;

    String codigoBuscado = codigo.toUpperCase();

    for (Libro l : libros) {
        if (l.getCodigo().equalsIgnoreCase(codigoBuscado))
            return l;
    }

    for (Revista r : revistas) {
        if (r.getCodigo().equalsIgnoreCase(codigoBuscado))
            return r;
    }

    return null;
}


ðŸ§  Estructura universal:

public Tipo buscar(String clave) {
    if (clave == null) return null;

    for (Tipo t : lista) {
        if (t.getClave().equalsIgnoreCase(clave)) return t;
    }
    return null;
}

ðŸŸ¥ 3. ELIMINAR (siempre igual)
âœ” Ejemplo Material (Libro y Revista)
public boolean eliminar(String codigo) {
    Material encontrado = buscar(codigo);
    if (encontrado == null) return false;

    // Puede ser Libro o Revista
    if (encontrado instanceof Libro) {
        return libros.remove(encontrado);
    } else if (encontrado instanceof Revista) {
        return revistas.remove(encontrado);
    }

    return false;
}


ðŸ§  Estructura universal:

public boolean eliminar(String clave) {
    Objeto o = buscar(clave);
    if (o == null) return false;

    return lista.remove(o);
}


ðŸ‘‰ Siempre:

buscar

si existe â†’ remove

si no â†’ false

ðŸŸ¨ 4. ACTUALIZAR (siempre igual)
âœ” Ejemplo Material (Libro y Revista)
public boolean actualizarLibro(String codigoOriginal, Libro nuevo) {
    String cod = codigoOriginal.toUpperCase();

    for (int i = 0; i < libros.size(); i++) {
        if (libros.get(i).getCodigo().equalsIgnoreCase(cod)) {
            libros.set(i, nuevo);
            return true;
        }
    }
    return false;
}

public boolean actualizarRevista(String codigoOriginal, Revista nueva) {
    String cod = codigoOriginal.toUpperCase();

    for (int i = 0; i < revistas.size(); i++) {
        if (revistas.get(i).getCodigo().equalsIgnoreCase(cod)) {
            revistas.set(i, nueva);
            return true;
        }
    }
    return false;
}


ðŸ§  Estructura universal:

public boolean actualizar(String claveOriginal, Tipo nuevo) {
    for (int i = 0; i < lista.size(); i++) {
        if (lista.get(i).getClave().equalsIgnoreCase(claveOriginal)) {
            lista.set(i, nuevo);
            return true;
        }
    }
    return false;
}


ðŸ‘‰ Siempre:

recorrer lista

encontrar Ã­ndice

usar set(i, nuevo)

ðŸŸ© 2. ESTRUCTURA PARA SUBCLASE (Ejemplo: Libro)
class Libro extends Material {

    private String autor;
    private int numeroPaginas;

    public Libro(String codigo, String titulo, int anioPublicacion,
                 String autor, int numeroPaginas) {
        super(codigo, titulo, anioPublicacion);
        this.autor = autor;
        this.numeroPaginas = numeroPaginas;
    }

    public String getAutor() {
        return autor;
    }

    public int getNumeroPaginas() {
        return numeroPaginas;
    }

    @Override
    public String getTipo() {
        return "LIBRO";
    }
}

ðŸŸ¥ 3. ESTRUCTURA PARA SUBCLASE CON EXCEPCIÃ“N (Ejemplo: Revista)

Primero: la excepciÃ³n

public class EdicionInvalidaException extends Exception {

    public EdicionInvalidaException() {
        super("Error: el nÃºmero de ediciÃ³n debe ser al menos 1.");
    }

    public EdicionInvalidaException(String msg) {
        super(msg);
    }
}


Ahora la clase Revista:

class Revista extends Material {

    private String editorial;
    private int numeroEdicion;

    public Revista(String codigo, String titulo, int anioPublicacion,
                   String editorial, int numeroEdicion)
                   throws EdicionInvalidaException {
        super(codigo, titulo, anioPublicacion);

        if (numeroEdicion < 1) {
            throw new EdicionInvalidaException();
        }

        this.editorial = editorial;
        this.numeroEdicion = numeroEdicion;
    }

    public String getEditorial() {
        return editorial;
    }

    public int getNumeroEdicion() {
        return numeroEdicion;
    }

    @Override
    public String getTipo() {
        return "REVISTA";
    }
}

ðŸŸ¨ 4. ESTRUCTURA INVENTARIO (CRUD COMPLETO)
public class Inventario {

    private ArrayList<Libro> libros;
    private ArrayList<Revista> revistas;

    public Inventario() {
        libros = new ArrayList<>();
        revistas = new ArrayList<>();
    }

    // ---------- AGREGAR ----------
    public void agregarLibro(Libro l) {
        libros.add(l);
    }

    public void agregarRevista(Revista r) {
        revistas.add(r);
    }

    // ---------- BUSCAR ----------
    public Material buscarMaterial(String codigo) {
        if (codigo == null) return null;

        String buscada = codigo.toUpperCase();

        for (Libro l : libros) {
            if (l.getCodigo().equalsIgnoreCase(buscada)) return l;
        }
        for (Revista r : revistas) {
            if (r.getCodigo().equalsIgnoreCase(buscada)) return r;
        }

        return null;
    }

    // ---------- ELIMINAR ----------
    public boolean eliminarMaterial(String codigo) {
        Material m = buscarMaterial(codigo);
        if (m == null) return false;

        if (m instanceof Libro) return libros.remove(m);
        if (m instanceof Revista) return revistas.remove(m);

        return false;
    }

    // ---------- ACTUALIZAR ----------
    public boolean actualizarLibro(String codigoOriginal, Libro nuevo) {
        String cod = codigoOriginal.toUpperCase();

        for (int i = 0; i < libros.size(); i++) {
            if (libros.get(i).getCodigo().equalsIgnoreCase(cod)) {
                libros.set(i, nuevo);
                return true;
            }
        }
        return false;
    }

    public boolean actualizarRevista(String codigoOriginal, Revista nueva) {
        String cod = codigoOriginal.toUpperCase();

        for (int i = 0; i < revistas.size(); i++) {
            if (revistas.get(i).getCodigo().equalsIgnoreCase(cod)) {
                revistas.set(i, nueva);
                return true;
            }
        }
        return false;
    }
}

âœ” ACÃ TENÃ‰S LA CLASE APARATO CORRECTA, COMPLETA Y 10/10

Copiala asÃ­:

abstract class Aparato {

    protected String codigoInterno;
    protected String nombre;
    protected int anioCompra;
    protected int horasUso;

    public Aparato(String codigoInterno, String nombre, int anioCompra, int horasUso) {
        this.codigoInterno = codigoInterno.toUpperCase();
        this.nombre = nombre.toUpperCase();
        this.anioCompra = anioCompra;
        this.horasUso = horasUso;
    }

    // ==========================
    // GETTERS
    // ==========================
    public String getCodigoInterno() {
        return codigoInterno;
    }

    public String getNombre() {
        return nombre;
    }

    public int getAnioCompra() {
        return anioCompra;
    }

    public int getHorasUso() {
        return horasUso;
    }

    // ==========================
    // MÃ‰TODO ABSTRACTO
    // ==========================
    public abstract String verTipoDeAparato();

    // ==========================
    // EQUALS Y HASHCODE
    // ==========================
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;

        Aparato otro = (Aparato) obj;

        return this.codigoInterno.equalsIgnoreCase(otro.codigoInterno);
    }

    @Override
    public int hashCode() {
        return codigoInterno.toUpperCase().hashCode();
    }
}
