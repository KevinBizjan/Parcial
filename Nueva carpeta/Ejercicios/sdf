 // ====== ESTRUCTURA UNIVERSAL EQUALS/HASHCODE ======
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;

        Material otro = (Material) obj;

        return this.codigo.equalsIgnoreCase(otro.codigo);
    }

    @Override
    public int hashCode() {
        return codigo.toUpperCase().hashCode();
    }
}

ðŸŸ¦ 1. AGREGAR (siempre igual)
âœ” Ejemplo Material (Libro y Revista)
public void agregarLibro(Libro l) {
    libros.add(l);
}

public void agregarRevista(Revista r) {
    revistas.add(r);
}


ðŸ§  Estructura universal:

public void agregar(Tipo obj) {
    lista.add(obj);
}


ðŸ‘‰ Da igual si es libros.add(l) o autos.add(a) o computadoras.add(c).

ðŸŸ© 2. BUSCAR (siempre igual)
âœ” Ejemplo Material (Libro y Revista)
public Material buscar(String codigo) {
    if (codigo == null) return null;

    String codigoBuscado = codigo.toUpperCase();

    for (Libro l : libros) {
        if (l.getCodigo().equalsIgnoreCase(codigoBuscado))
            return l;
    }

    for (Revista r : revistas) {
        if (r.getCodigo().equalsIgnoreCase(codigoBuscado))
            return r;
    }

    return null;
}


ðŸ§  Estructura universal:

public Tipo buscar(String clave) {
    if (clave == null) return null;

    for (Tipo t : lista) {
        if (t.getClave().equalsIgnoreCase(clave)) return t;
    }
    return null;
}

ðŸŸ¥ 3. ELIMINAR (siempre igual)
âœ” Ejemplo Material (Libro y Revista)
public boolean eliminar(String codigo) {
    Material encontrado = buscar(codigo);
    if (encontrado == null) return false;

    // Puede ser Libro o Revista
    if (encontrado instanceof Libro) {
        return libros.remove(encontrado);
    } else if (encontrado instanceof Revista) {
        return revistas.remove(encontrado);
    }

    return false;
}


ðŸ§  Estructura universal:

public boolean eliminar(String clave) {
    Objeto o = buscar(clave);
    if (o == null) return false;

    return lista.remove(o);
}


ðŸ‘‰ Siempre:

buscar

si existe â†’ remove

si no â†’ false

ðŸŸ¨ 4. ACTUALIZAR (siempre igual)
âœ” Ejemplo Material (Libro y Revista)
public boolean actualizarLibro(String codigoOriginal, Libro nuevo) {
    String cod = codigoOriginal.toUpperCase();

    for (int i = 0; i < libros.size(); i++) {
        if (libros.get(i).getCodigo().equalsIgnoreCase(cod)) {
            libros.set(i, nuevo);
            return true;
        }
    }
    return false;
}

public boolean actualizarRevista(String codigoOriginal, Revista nueva) {
    String cod = codigoOriginal.toUpperCase();

    for (int i = 0; i < revistas.size(); i++) {
        if (revistas.get(i).getCodigo().equalsIgnoreCase(cod)) {
            revistas.set(i, nueva);
            return true;
        }
    }
    return false;
}


ðŸ§  Estructura universal:

public boolean actualizar(String claveOriginal, Tipo nuevo) {
    for (int i = 0; i < lista.size(); i++) {
        if (lista.get(i).getClave().equalsIgnoreCase(claveOriginal)) {
            lista.set(i, nuevo);
            return true;
        }
    }
    return false;
}


ðŸ‘‰ Siempre:

recorrer lista

encontrar Ã­ndice

usar set(i, nuevo)

ðŸŸ© 2. ESTRUCTURA PARA SUBCLASE (Ejemplo: Libro)
class Libro extends Material {

    private String autor;
    private int numeroPaginas;

    public Libro(String codigo, String titulo, int anioPublicacion,
                 String autor, int numeroPaginas) {
        super(codigo, titulo, anioPublicacion);
        this.autor = autor;
        this.numeroPaginas = numeroPaginas;
    }

    public String getAutor() {
        return autor;
    }

    public int getNumeroPaginas() {
        return numeroPaginas;
    }

    @Override
    public String getTipo() {
        return "LIBRO";
    }
}

ðŸŸ¥ 3. ESTRUCTURA PARA SUBCLASE CON EXCEPCIÃ“N (Ejemplo: Revista)

Primero: la excepciÃ³n

public class EdicionInvalidaException extends Exception {

    public EdicionInvalidaException() {
        super("Error: el nÃºmero de ediciÃ³n debe ser al menos 1.");
    }

    public EdicionInvalidaException(String msg) {
        super(msg);
    }
}


Ahora la clase Revista:

class Revista extends Material {

    private String editorial;
    private int numeroEdicion;

    public Revista(String codigo, String titulo, int anioPublicacion,
                   String editorial, int numeroEdicion)
                   throws EdicionInvalidaException {
        super(codigo, titulo, anioPublicacion);

        if (numeroEdicion < 1) {
            throw new EdicionInvalidaException();
        }

        this.editorial = editorial;
        this.numeroEdicion = numeroEdicion;
    }

    public String getEditorial() {
        return editorial;
    }

    public int getNumeroEdicion() {
        return numeroEdicion;
    }

    @Override
    public String getTipo() {
        return "REVISTA";
    }
}

ðŸŸ¨ 4. ESTRUCTURA INVENTARIO (CRUD COMPLETO)
public class Inventario {

    private ArrayList<Libro> libros;
    private ArrayList<Revista> revistas;

    public Inventario() {
        libros = new ArrayList<>();
        revistas = new ArrayList<>();
    }

    // ---------- AGREGAR ----------
    public void agregarLibro(Libro l) {
        libros.add(l);
    }

    public void agregarRevista(Revista r) {
        revistas.add(r);
    }

    // ---------- BUSCAR ----------
    public Material buscarMaterial(String codigo) {
        if (codigo == null) return null;

        String buscada = codigo.toUpperCase();

        for (Libro l : libros) {
            if (l.getCodigo().equalsIgnoreCase(buscada)) return l;
        }
        for (Revista r : revistas) {
            if (r.getCodigo().equalsIgnoreCase(buscada)) return r;
        }

        return null;
    }

    // ---------- ELIMINAR ----------
    public boolean eliminarMaterial(String codigo) {
        Material m = buscarMaterial(codigo);
        if (m == null) return false;

        if (m instanceof Libro) return libros.remove(m);
        if (m instanceof Revista) return revistas.remove(m);

        return false;
    }

    // ---------- ACTUALIZAR ----------
    public boolean actualizarLibro(String codigoOriginal, Libro nuevo) {
        String cod = codigoOriginal.toUpperCase();

        for (int i = 0; i < libros.size(); i++) {
            if (libros.get(i).getCodigo().equalsIgnoreCase(cod)) {
                libros.set(i, nuevo);
                return true;
            }
        }
        return false;
    }

    public boolean actualizarRevista(String codigoOriginal, Revista nueva) {
        String cod = codigoOriginal.toUpperCase();

        for (int i = 0; i < revistas.size(); i++) {
            if (revistas.get(i).getCodigo().equalsIgnoreCase(cod)) {
                revistas.set(i, nueva);
                return true;
            }
        }
        return false;
    }
}

âœ” ACÃ TENÃ‰S LA CLASE APARATO CORRECTA, COMPLETA Y 10/10

Copiala asÃ­:

abstract class Aparato {

    protected String codigoInterno;
    protected String nombre;
    protected int anioCompra;
    protected int horasUso;

    public Aparato(String codigoInterno, String nombre, int anioCompra, int horasUso) {
        this.codigoInterno = codigoInterno.toUpperCase();
        this.nombre = nombre.toUpperCase();
        this.anioCompra = anioCompra;
        this.horasUso = horasUso;
    }

    // ==========================
    // GETTERS
    // ==========================
    public String getCodigoInterno() {
        return codigoInterno;
    }

    public String getNombre() {
        return nombre;
    }

    public int getAnioCompra() {
        return anioCompra;
    }

    public int getHorasUso() {
        return horasUso;
    }

    // ==========================
    // MÃ‰TODO ABSTRACTO
    // ==========================
    public abstract String verTipoDeAparato();

    // ==========================
    // EQUALS Y HASHCODE
    // ==========================
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;

        Aparato otro = (Aparato) obj;

        return this.codigoInterno.equalsIgnoreCase(otro.codigoInterno);
    }

    @Override
    public int hashCode() {
        return codigoInterno.toUpperCase().hashCode();
    }
}

ðŸŸ¦ MAQUINA CARDIO

Hereda de Aparato e implementa Vendible.

âœ” Atributo adicional:

nivelImpacto (1, 2 o 3)

âœ” Reglas del precio:

10% de depreciaciÃ³n por aÃ±o

Tope del 80%

Si nivelImpacto == 3 â‡’ descuento extra 5%

âœ” CÃ“DIGO COMPLETO DE MAQUINACARDIO
public class MaquinaCardio extends Aparato implements Vendible {

    private int nivelImpacto;

    public MaquinaCardio(String codigoInterno, String nombre, int anioCompra,
                         int horasUso, int nivelImpacto) {
        super(codigoInterno, nombre, anioCompra, horasUso);
        this.nivelImpacto = nivelImpacto;
    }

    public int getNivelImpacto() {
        return nivelImpacto;
    }

    @Override
    public String verTipoDeAparato() {
        return "CARDIO";
    }

    @Override
    public double calcularPrecioVenta(double precioBase, int anioActual) {
        int aniosDeUso = anioActual - this.anioCompra;
        if (aniosDeUso < 0) aniosDeUso = 0;

        double depreciacion = aniosDeUso * 0.10;  // 10% por aÃ±o
        if (depreciacion > 0.80) depreciacion = 0.80; // tope del 80%

        double precioDepreciado = precioBase * (1 - depreciacion);

        // Descuento extra si tiene alto impacto
        if (nivelImpacto == 3) {
            precioDepreciado *= 0.95; // 5% de descuento
        }

        return precioDepreciado;
    }
}

ðŸŸ© MAQUINA MUSCULACIÃ“N (sin excepciÃ³n por ahora)
âœ” Atributo adicional:

cantidadEstaciones

âœ” Reglas del precio:

8% depreciaciÃ³n por aÃ±o

Tope 70%

Si cantidadEstaciones > 4 â‡’ RECARGO del 3% (se suma, no se descuenta)

âœ” CÃ“DIGO COMPLETO DE MAQUINAMUSCULACION
public class MaquinaMusculacion extends Aparato implements Vendible {

    private int cantidadEstaciones;

    public MaquinaMusculacion(String codigoInterno, String nombre,
                              int anioCompra, int horasUso,
                              int cantidadEstaciones) {
        super(codigoInterno, nombre, anioCompra, horasUso);
        this.cantidadEstaciones = cantidadEstaciones;
    }

    public int getCantidadEstaciones() {
        return cantidadEstaciones;
    }

    @Override
    public String verTipoDeAparato() {
        return "MUSCULACIÃ“N";
    }

    @Override
    public double calcularPrecioVenta(double precioBase, int anioActual) {
        int aniosDeUso = anioActual - this.anioCompra;
        if (aniosDeUso < 0) aniosDeUso = 0;

        double depreciacion = aniosDeUso * 0.08; // 8% por aÃ±o
        if (depreciacion > 0.70) depreciacion = 0.70; // tope del 70%

        double precioDepreciado = precioBase * (1 - depreciacion);

        // Recargo si tiene muchas estaciones
        if (cantidadEstaciones > 4) {
            precioDepreciado *= 1.03; // +3%
        }

        return precioDepreciado;
    }
}

ðŸŸ¥ EJERCICIO 3 â€“ ExcepciÃ³n EstacionesInsuficientesException

La consigna decÃ­a:

Si una mÃ¡quina de musculaciÃ³n tiene menos de 2 estaciones,
debe lanzarse una excepciÃ³n verificada.

Eso significa:

Crear la clase de excepciÃ³n (extends Exception)

AgregÃ¡rsela al constructor de MaquinaMusculacion

Lanzarla si cantidadEstaciones < 2

Vamos parte por parte.

âœ… 1. Clase de excepciÃ³n (completa y exacta)

CopiÃ¡ esto tal cual:

public class EstacionesInsuficientesException extends Exception {

    public EstacionesInsuficientesException() {
        super("Error: una mÃ¡quina de musculaciÃ³n debe tener al menos 2 estaciones.");
    }

    public EstacionesInsuficientesException(String mensaje) {
        super(mensaje);
    }
}

âœ… 2. Agregar la excepciÃ³n al constructor de MaquinaMusculacion

TenÃ­as esto antes:

public MaquinaMusculacion(String codigoInterno, String nombre,
                          int anioCompra, int horasUso,
                          int cantidadEstaciones) {
    super(codigoInterno, nombre, anioCompra, horasUso);
    this.cantidadEstaciones = cantidadEstaciones;
}


Ahora debe quedar asÃ­:

public MaquinaMusculacion(String codigoInterno, String nombre,
                          int anioCompra, int horasUso,
                          int cantidadEstaciones)
                          throws EstacionesInsuficientesException {

    super(codigoInterno, nombre, anioCompra, horasUso);

    if (cantidadEstaciones < 2) {
        throw new EstacionesInsuficientesException();
    }

    this.cantidadEstaciones = cantidadEstaciones;
}
