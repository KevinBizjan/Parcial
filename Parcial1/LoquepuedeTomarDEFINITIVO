ğŸ¯ POSIBLE ESTRUCTURA DEL RECUPERATORIO

(Esto es EXACTAMENTE lo que el profe Uferer suele tomar)

ğŸ“Œ CLASES BASE DADAS POR Ã‰L

Ã‰l te da algo asÃ­:

class Persona {
    protected String nombre;
    protected String apellido;

    public Persona(String nombre, String apellido) {
        this.nombre = nombre;
        this.apellido = apellido;
    }

    public String toString() {
        return apellido + ", " + nombre;
    }
}

interface Informable {
    String generarInforme();
}


Y despuÃ©s te pide:

ğŸ§© 1 clase que hereda de Persona + implementa Informable + sobreescritura

Ejemplo que puede tomar:

class Empleado extends Persona implements Informable {
    private String sector;

    public Empleado(String nombre, String apellido, String sector) {
        super(nombre, apellido);
        this.sector = sector;
    }

    @Override
    public String generarInforme() {
        return "Empleado: " + super.toString() + " - Sector: " + sector;
    }

    @Override
    public String toString() {
        return super.toString() + " - Sector: " + sector;
    }
}


Esto cumple EXACTAMENTE lo que dijo:

âœ” herencia
âœ” sobreescritura (toString)
âœ” implementaciÃ³n de interfaz
âœ” mÃ©todo implementado

ğŸ”¥ LAS 3 FUNCIONES QUE TE PUEDE TOMAR

Te las detallo en modo EXAMEN.

ğŸ“Œ FUNCIÃ“N 1 (muy tÃ­pica)
â¤ â€œRegistrar un empleado/profesor/administrativoâ€

Siempre pide lo mismo:

public static Empleado registrarEmpleado(Scanner sc) {
    System.out.print("Nombre: ");
    String nombre = sc.nextLine();

    System.out.print("Apellido: ");
    String apellido = sc.nextLine();

    System.out.print("Sector: ");
    String sector = sc.nextLine();

    return new Empleado(nombre, apellido, sector);
}


âœ” pide datos
âœ” crea el objeto
âœ” lo devuelve
âœ” debe usar new

ğŸ“Œ FUNCIÃ“N 2
â¤ â€œMostrar los elementos de un arreglo ignorando las posiciones vacÃ­asâ€

Esto SIEMPRE lo toma:

public static void mostrarEmpleados(Empleado[] lista) {
    for (int i = 0; i < lista.length; i++) {
        if (lista[i] != null) {
            System.out.println(lista[i].toString());
        }
    }
}


âœ” for clÃ¡sico
âœ” null-check
âœ” toString

ğŸ“Œ FUNCIÃ“N 3
â¤ â€œMostrar un informe si el objeto implementa Informableâ€

Y como NO quiere instanceof, lo toma ASÃ:

public static void mostrarInforme(Informable obj) {
    System.out.println(obj.generarInforme());
}


Si el objeto tiene materias, sector, etc., eso se agrega en la clase misma.

ğŸ§¨ OPCIONAL: FUNCIÃ“N ADICIONAL QUE A VECES TOMA
â¤ Buscar por nombre/DNI en el array
public static Empleado buscarEmpleado(Empleado[] lista, String nombre) {
    for (int i = 0; i < lista.length; i++) {
        if (lista[i] != null && lista[i].nombre.equals(nombre)) {
            return lista[i];
        }
    }
    return null;
}


Aunque este aÃ±o no lo pidiÃ³, podrÃ­a pedirlo.

ğŸ”¥ MENÃš (si te lo pide como cuarta consigna)
public static void menu() {
    Scanner sc = new Scanner(System.in);
    Empleado[] empleados = new Empleado[10];
    int contador = 0;

    int opcion;
    do {
        System.out.println("1. Registrar empleado");
        System.out.println("2. Mostrar empleados");
        System.out.println("3. Mostrar informe");
        System.out.println("4. Salir");

        opcion = sc.nextInt();
        sc.nextLine();

        switch (opcion) {
            case 1:
                empleados[contador] = registrarEmpleado(sc);
                contador++;
                break;
            case 2:
                mostrarEmpleados(empleados);
                break;
            case 3:
                mostrarInforme(empleados[0]);
                break;
        }
    } while (opcion != 4);
}
